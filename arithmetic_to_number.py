# -*- coding: utf-8 -*-
"""arithmetic_combs_and_perms.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kT-EIbbW_zxfEqfbzArzdaLNytObo5U-
"""

import itertools
from pprint import pprint

def plus(x, y):
    return x + y
def minus(x, y):
    return x - y
def times(x, y):
    return x * y
def divided_by(x, y):
    return x / y

def make_tree(nbs, split_p, lvl=0, shift=0):
    if len(nbs) == 1:
        return nbs[0]

    while True:
        # print(nbs, split_p, lvl, shift, '', sep='\n')
        split = split_p[lvl] - shift
        if split > 0 and split < len(nbs):
            break
        lvl += 1

    part_a = make_tree(nbs[:split], split_p, lvl+1, shift)
    part_b = make_tree(nbs[split:], split_p, lvl+1, shift+split)
    return (
        part_a,
        part_b,
        )

def compute(order, op_p, lvl=0):
    values = []
    phrases = []
    for part in order:
        # print(part)
        try:
            value, phrase = compute(part, op_p, lvl+1)
            values.append(value)
            phrases.append(phrase)
        except TypeError:
            values.append(part)
            phrases.append(f"{part}")

    op = op_p.pop()
    try:
        value = op(*values)
    except ZeroDivisionError:
        value = float("NaN")
    # print(f"({phrases[0]} {op.__name__} {phrases[1]})")
    # print(value)
    # print()
    return (
        value,
        f"({phrases[0]} {op.__name__} {phrases[1]})"
        )

nbs = [75, 25, 4, 100]
ops = [plus, minus, times]
re = 425

nb_ps = list(itertools.permutations(nbs))
op_ps = list(itertools.permutations(ops))

orders = set()
for split_p in itertools.permutations(range(1, len(nbs))):
    for nb_p in nb_ps:
        orders.add(make_tree(nb_p, split_p))
# pprint(orders)
# print(len(orders))

for order in orders:
    for op_p in op_ps:
        result = compute(order, list(op_p))
        if result[0] == re:
            print(f"{result[1]} = {result[0]}")

print(len(orders), len(op_ps))
